package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"context"
	"fmt"

	"github.com/bdreece/hopper/pkg/models"
	"github.com/bdreece/hopper/pkg/utils/iter"
)

// Devices is the resolver for the devices field.
func (r *queryResolver) Devices(ctx context.Context) ([]*models.Device, error) {
	const (
		resolver = "QueryResolver"
		field    = "Devices"
	)

	logger := r.logger.
		WithContext(resolver).
		WithContext(field)

	logger.Infoln("Querying for devices...")
	devices := make([]models.Device, 0, 1)
	err := r.db.Find(&devices).Error
	if err != nil {
		return nil, handleQueryError(err, logger, field)
	}

	logger.Infoln("Devices received!")
	return iter.Collect(iter.NewMap(
		iter.FromSlice(&devices),
		func(in *models.Device) *models.Device { return in },
	)), nil
}

// DeviceModels is the resolver for the deviceModels field.
func (r *queryResolver) DeviceModels(ctx context.Context) ([]*models.DeviceModel, error) {
	const (
		resolver = "QueryResolver"
		field    = "DeviceModels"
	)

	logger := r.logger.
		WithContext(resolver).
		WithContext(field)

	logger.Infoln("Querying for device models...")
	deviceModels := make([]models.DeviceModel, 0, 1)
	err := r.db.Find(&deviceModels).Error
	if err != nil {
		return nil, handleQueryError(err, logger, field)
	}

	logger.Infoln("Device models received!")
	return iter.Collect(iter.NewMap(
		iter.FromSlice(&deviceModels),
		func(in *models.DeviceModel) *models.DeviceModel { return in },
	)), nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context) ([]*models.Event, error) {
	const (
		resolver = "QueryResolver"
		field    = "Events"
	)

	logger := r.logger.
		WithContext(resolver).
		WithContext(field)

	logger.Infoln("Querying for events...")
	events := make([]models.Event, 0, 1)
	err := r.db.Find(&events).Error
	if err != nil {
		return nil, handleQueryError(err, logger, field)
	}

	logger.Infoln("Events received")
	return iter.Collect(iter.NewMap(
		iter.FromSlice(&events),
		func(in *models.Event) *models.Event { return in },
	)), nil
}

// Firmwares is the resolver for the firmwares field.
func (r *queryResolver) Firmwares(ctx context.Context) ([]*models.Firmware, error) {
	panic(fmt.Errorf("not implemented: Firmwares - firmwares"))
}

// Properties is the resolver for the properties field.
func (r *queryResolver) Properties(ctx context.Context) ([]*models.Property, error) {
	panic(fmt.Errorf("not implemented: Properties - properties"))
}

// Tenants is the resolver for the tenants field.
func (r *queryResolver) Tenants(ctx context.Context) ([]*models.Tenant, error) {
	panic(fmt.Errorf("not implemented: Tenants - tenants"))
}

// Types is the resolver for the types field.
func (r *queryResolver) Types(ctx context.Context) ([]*models.Type, error) {
	panic(fmt.Errorf("not implemented: Types - types"))
}

// Units is the resolver for the units field.
func (r *queryResolver) Units(ctx context.Context) ([]*models.Unit, error) {
	panic(fmt.Errorf("not implemented: Units - units"))
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
